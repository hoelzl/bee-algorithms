#Tue Apr 05 23:28:06 CEST 2011
cmdhistory=[";; Loading file src/beeAlgorithms/core.clj" "(clojure.lang.Compiler/load (java.io.StringReader. \\"(ns beeAlgorithms.core\\\\n  (\:gen-class)\\\\n  (\:use (incanter core stats charts\\\\n\\\\t\\\\t  [distributions \:exclude [variance mean]])))\\\\n\\\\n\\\\n(def *number-of-bees* 100)\\\\n(def *end-time* 120)\\\\n(def *time-step* 1)\\\\n\\\\n(defn make-example [& {\:keys [start-cooling-distribution\\\\n\\\\t\\\\t\\\\t      stop-cooling-distribution\\\\n\\\\t\\\\t\\\\t      number-of-bees\\\\n\\\\t\\\\t\\\\t      delta-temp\\\\n\\\\t\\\\t\\\\t      end-time\\\\n\\\\t\\\\t\\\\t      time-step\\\\n\\\\t\\\\t\\\\t      title],\\\\n\\\\t\\\\t       \:or {start-cooling-distribution (normal-distribution 2.0 1.0),\\\\n\\\\t\\\\t\\\\t    stop-cooling-distribution (normal-distribution 0.0 0.1),\\\\n\\\\t\\\\t\\\\t    number-of-bees *number-of-bees*,\\\\n\\\\t\\\\t\\\\t    delta-temp (/ 1 *number-of-bees*)\\\\n\\\\t\\\\t\\\\t    end-time *end-time*\\\\n\\\\t\\\\t\\\\t    time-step *time-step*\\\\n\\\\t\\\\t\\\\t    title \\\\\\"Unnamed Example\\\\\\"}}]\\\\n  {\:start-cooling-disribution start-cooling-distribution,\\\\n   \:stop-cooling-distribution stop-cooling-distribution,\\\\n   \:number-of-bees number-of-bees\\\\n   \:delta-temp delta-temp\\\\n   \:end-time end-time\\\\n   \:time-step time-step\\\\n   \:title title})\\\\n\\\\n(def $default-example (make-example \:start-cooling-disribution (normal-distribution 1.0 0.5)\\\\n\\\\t\\\\t\\\\t\\\\t    \:stop-cooling-distribution (normal-distribution 0.5 0.1)\\\\n\\\\t\\\\t\\\\t\\\\t    \:number-of-bees *number-of-bees*\\\\n\\\\t\\\\t\\\\t\\\\t    \:delta-temp (/ 1 *number-of-bees*)\\\\n\\\\t\\\\t\\\\t\\\\t    \:title \\\\\\"Normally Distributed Default Example\\\\\\"))\\\\n\\\\n(def $fixed-example (make-example \:start-cooling-disribution [1.0]\\\\n\\\\t\\\\t\\\\t\\\\t  \:stop-cooling-distribution [0.5]\\\\n\\\\t\\\\t\\\\t\\\\t  \:number-of-bees *number-of-bees*\\\\n\\\\t\\\\t\\\\t\\\\t  \:delta-temp (/ 1 *number-of-bees*)\\\\n\\\\t\\\\t\\\\t\\\\t  \:title \\\\\\"Fixed Distribution\\\\\\"))\\\\n(def $pi java.lang.Math/PI)\\\\n\\\\n(defn sin-1 [x]\\\\n  (if (< x 0)\\\\n    0.0\\\\n    (let [scaled-x (/ x 2)]\\\\n      (sin scaled-x))))\\\\n\\\\n(defn accelerated-sin-2 [x]\\\\n  (if (< x 0)\\\\n    0.0\\\\n    (let [scaled-x (/ x $pi 10.0)]\\\\n      (sin (* $pi scaled-x scaled-x)))))\\\\n\\\\n(defn accelerated-sin-3 [x]\\\\n  (if (< x 0)\\\\n    0.0\\\\n    (let [scaled-x (/ x $pi 10.0)]\\\\n      (sin (* 0.3 $pi scaled-x scaled-x scaled-x)))))\\\\n\\\\n(defn accelerated-sin-exp [x]\\\\n  (if (< x 0)\\\\n    0.0\\\\n    (let [scaled-x (/ x $pi 10)]\\\\n      (sin (- (exp scaled-x) 1)))))\\\\n\\\\n(defn make-external-temperature-fun [max driver-fun]\\\\n  (fn [t]\\\\n    (* max (driver-fun t))))\\\\n\\\\n(def external-temperature\\\\n     (make-external-temperature-fun 5.0 accelerated-sin-exp))\\\\n\\\\n(def *bees* (atom []))\\\\n\\\\n(defn make-bees [example]\\\\n  (let [start-cooling-distribution (\:start-cooling-disribution example)\\\\n\\\\tstop-cooling-distribution (\:stop-cooling-distribution example)\\\\n\\\\tnumber-of-bees (\:number-of-bees example)\\\\n\\\\tdelta-temp (\:delta-temp example)\\\\n\\\\tbees (for [i (range number-of-bees)]\\\\n\\\\t       (let [start-cooling (abs (draw start-cooling-distribution))\\\\n\\\\t\\\\t     stop-cooling (min (draw stop-cooling-distribution) (- start-cooling 0.5))\\\\n\\\\t\\\\t     start-heating (- start-cooling)\\\\n\\\\t\\\\t     stop-heating (- stop-cooling)]\\\\n\\\\t\\\\t {\:type \:\:bee,\\\\n\\\\t\\\\t  \:start-cooling start-cooling\\\\n\\\\t\\\\t  \:stop-cooling stop-cooling\\\\n\\\\t\\\\t  \:start-heating start-heating\\\\n\\\\t\\\\t  \:stop-heating stop-heating\\\\n\\\\t\\\\t  \:delta-temp delta-temp\\\\n\\\\t\\\\t  \:previous-action (atom \:\:none)}))]\\\\n    (swap\! *bees* (fn [atom] bees))\\\\n    bees))\\\\n\\\\n(defn bee-action [bee temperature]\\\\n  (let [previous-action (\:previous-action bee)\\\\n\\\\tprevious-action-value @previous-action]\\\\n    ;; Using this function bees cannot transition directly from\\\\n    ;; heating to cooling and vice versa.  Not sure whether this is correct.\\\\n    (cond (\= previous-action-value \:\:cooling)\\\\n\\\\t  (if (< temperature (\:stop-cooling bee))\\\\n\\\\t    (do\\\\n\\\\t      (swap\! previous-action (fn [action] \:\:none))\\\\n\\\\t      0.0)\\\\n\\\\t    (- (\:delta-temp bee)))\\\\n\\\\t  (\= previous-action-value \:\:heating)\\\\n\\\\t  (if (> temperature (\:stop-heating bee))\\\\n\\\\t    (do\\\\n\\\\t      (swap\! previous-action (fn [action] \:\:none))\\\\n\\\\t      0.0)\\\\n\\\\t    (\:delta-temp bee))\\\\n\\\\t  (\= previous-action-value \:\:none)\\\\n\\\\t  (cond (>\= temperature (\:start-cooling bee))\\\\n\\\\t\\\\t(do\\\\n\\\\t\\\\t  (swap\! previous-action (fn [action] \:\:cooling))\\\\n\\\\t\\\\t  (- (\:delta-temp bee)))\\\\n\\\\t\\\\t(<\= temperature (\:start-heating bee))\\\\n\\\\t\\\\t(do\\\\n\\\\t\\\\t  (swap\! previous-action (fn [action] \:\:heating))\\\\n\\\\t\\\\t  (\:delta-temp bee))\\\\n\\\\t\\\\t\:else 0.0))))\\\\n\\\\n\\\\n(defn bee-actions [bees temperature]\\\\n  (sum (map \#(bee-action % temperature) bees)))\\\\n\\\\n(defn with-offset\\\\n  ([sequence]\\\\n     (cons (first sequence) sequence))\\\\n  ([sequence n]\\\\n     (if (zero? n)\\\\n       sequence\\\\n       (recur (with-offset sequence) (- n 1)))))\\\\n\\\\n(defn time-seq [example]\\\\n  (range 0 (\:end-time example)  (\:time-step example)))\\\\n\\\\n(defn delta-t-seq [external-temperature-seq]\\\\n  (map - external-temperature-seq (with-offset external-temperature-seq)))\\\\n\\\\n(defn result-temperatures [current-t delta-t-env bees]\\\\n  (let [current-delta-t-env (first delta-t-env)\\\\n\\\\tcurrent-delta-t-bees (bee-actions bees current-t)\\\\n\\\\tnext-t (+ current-t current-delta-t-env current-delta-t-bees)]\\\\n    (println [current-t current-delta-t-env current-delta-t-bees])\\\\n    (lazy-seq\\\\n     (cons current-t\\\\n\\\\t   (let [new-delta-t-env (rest delta-t-env)]\\\\n\\\\t\\\\t (if (seq new-delta-t-env)\\\\n\\\\t\\\\t   (result-temperatures next-t new-delta-t-env bees)\\\\n\\\\t\\\\t   []))))))\\\\n\\\\n(defn plot-result [& {\:keys {example\\\\n\\\\t\\\\t\\\\t     times\\\\n\\\\t\\\\t\\\\t     temperatures\\\\n\\\\t\\\\t\\\\t     title}}]\\\\n  (let [example (or example $default-example)\\\\n        times (or times (time-seq example))\\\\n        temperatures (or temperatures (map external-temperature times))\\\\n\\\\ttitle (or title (\:title example) \\\\\\"Temperature Plot\\\\\\")]\\\\n    (xy-plot times temperatures\\\\n     \\\\t     \:title title \\\\n     \\\\t     \:x-label \\\\\\"Time (min)\\\\\\" \:y-label \\\\\\"Temperature (\u00AC\u221EC)\\\\\\")))\\\\n\\\\n(defn run-example [example]\\\\n  (let [time (time-seq example)\\\\n\\\\ttemp (map external-temperature time)\\\\n\\\\tplot (plot-result \:example example \:time time \:temperature temp)\\\\n\\\\tbees (make-bees example)\\\\n\\\\tdelta-t-env  (delta-t-seq temp)\\\\n\\\\tresult-temp (result-temperatures 0.0 delta-t-env bees)]\\\\n    ;; (println delta-t-env)\\\\n    ;; (println result-temp)\\\\n    (add-lines plot time result-temp)\\\\n    (view plot)))\\\\n\\\\n(defn -main [& args]\\\\n  (run-example $default-example)\\\\n  (run-example $fixed-example))\\\\n\\") \\"/Users/tc/Prog/Clojure/Projects/bee-algorithms/src/beeAlgorithms/core.clj\\" \\"/Users/tc/Prog/Clojure/Projects/bee-algorithms/src\\")" "(ccw.debug.serverrepl/with-exception-serialization (clojure.core/binding [clojure.core/*compile-path* \\"classes\\"] (clojure.core/compile 'beeAlgorithms.core)))" "123" "(\= 1 1)" "(binding [*out* *err*] (if-not *e (println \\"No prior exception bound to *e.\\") (clojure.tools.nrepl/*print-error-detail* *e)))" "(-main)" ";; Switching to beeAlgorithms.core namespace" "(clojure.core/in-ns 'beeAlgorithms.core)" "(-main)" ";; Loading file src/beeAlgorithms/core.clj" "(clojure.lang.Compiler/load (java.io.StringReader. \\"(ns beeAlgorithms.core\\\\n  (\:gen-class)\\\\n  (\:use (incanter core stats charts\\\\n\\\\t\\\\t  [distributions \:exclude [variance mean]])))\\\\n\\\\n\\\\n(def *number-of-bees* 100)\\\\n(def *end-time* 120)\\\\n(def *time-step* 1)\\\\n\\\\n(defn make-example [& {\:keys [start-cooling-distribution\\\\n\\\\t\\\\t\\\\t      stop-cooling-distribution\\\\n\\\\t\\\\t\\\\t      number-of-bees\\\\n\\\\t\\\\t\\\\t      delta-temp\\\\n\\\\t\\\\t\\\\t      end-time\\\\n\\\\t\\\\t\\\\t      time-step\\\\n\\\\t\\\\t\\\\t      title],\\\\n\\\\t\\\\t       \:or {start-cooling-distribution (normal-distribution 2.0 1.0),\\\\n\\\\t\\\\t\\\\t    stop-cooling-distribution (normal-distribution 0.0 0.1),\\\\n\\\\t\\\\t\\\\t    number-of-bees *number-of-bees*,\\\\n\\\\t\\\\t\\\\t    delta-temp (/ 1 *number-of-bees*)\\\\n\\\\t\\\\t\\\\t    end-time *end-time*\\\\n\\\\t\\\\t\\\\t    time-step *time-step*\\\\n\\\\t\\\\t\\\\t    title \\\\\\"Unnamed Example\\\\\\"}}]\\\\n  {\:start-cooling-disribution start-cooling-distribution,\\\\n   \:stop-cooling-distribution stop-cooling-distribution,\\\\n   \:number-of-bees number-of-bees\\\\n   \:delta-temp delta-temp\\\\n   \:end-time end-time\\\\n   \:time-step time-step\\\\n   \:title title})\\\\n\\\\n(def $default-example (make-example \:start-cooling-disribution (normal-distribution 1.0 0.5)\\\\n\\\\t\\\\t\\\\t\\\\t    \:stop-cooling-distribution (normal-distribution 0.5 0.1)\\\\n\\\\t\\\\t\\\\t\\\\t    \:number-of-bees *number-of-bees*\\\\n\\\\t\\\\t\\\\t\\\\t    \:delta-temp (/ 1 *number-of-bees*)\\\\n\\\\t\\\\t\\\\t\\\\t    \:title \\\\\\"Normally Distributed Default Example\\\\\\"))\\\\n\\\\n(def $fixed-example (make-example \:start-cooling-disribution [1.0]\\\\n\\\\t\\\\t\\\\t\\\\t  \:stop-cooling-distribution [0.5]\\\\n\\\\t\\\\t\\\\t\\\\t  \:number-of-bees *number-of-bees*\\\\n\\\\t\\\\t\\\\t\\\\t  \:delta-temp (/ 1 *number-of-bees*)\\\\n\\\\t\\\\t\\\\t\\\\t  \:title \\\\\\"Fixed Distribution\\\\\\"))\\\\n(def $pi java.lang.Math/PI)\\\\n\\\\n(defn sin-1 [x]\\\\n  (if (< x 0)\\\\n    0.0\\\\n    (let [scaled-x (/ x 2)]\\\\n      (sin scaled-x))))\\\\n\\\\n(defn accelerated-sin-2 [x]\\\\n  (if (< x 0)\\\\n    0.0\\\\n    (let [scaled-x (/ x $pi 10.0)]\\\\n      (sin (* $pi scaled-x scaled-x)))))\\\\n\\\\n(defn accelerated-sin-3 [x]\\\\n  (if (< x 0)\\\\n    0.0\\\\n    (let [scaled-x (/ x $pi 10.0)]\\\\n      (sin (* 0.3 $pi scaled-x scaled-x scaled-x)))))\\\\n\\\\n(defn accelerated-sin-exp [x]\\\\n  (if (< x 0)\\\\n    0.0\\\\n    (let [scaled-x (/ x $pi 10)]\\\\n      (sin (- (exp scaled-x) 1)))))\\\\n\\\\n(defn make-external-temperature-fun [max driver-fun]\\\\n  (fn [t]\\\\n    (* max (driver-fun t))))\\\\n\\\\n(def external-temperature\\\\n     (make-external-temperature-fun 5.0 accelerated-sin-exp))\\\\n\\\\n(def *bees* (atom []))\\\\n\\\\n(defn make-bees [example]\\\\n  (let [start-cooling-distribution (\:start-cooling-disribution example)\\\\n\\\\tstop-cooling-distribution (\:stop-cooling-distribution example)\\\\n\\\\tnumber-of-bees (\:number-of-bees example)\\\\n\\\\tdelta-temp (\:delta-temp example)\\\\n\\\\tbees (for [i (range number-of-bees)]\\\\n\\\\t       (let [start-cooling (abs (draw start-cooling-distribution))\\\\n\\\\t\\\\t     stop-cooling (min (draw stop-cooling-distribution) (- start-cooling 0.5))\\\\n\\\\t\\\\t     start-heating (- start-cooling)\\\\n\\\\t\\\\t     stop-heating (- stop-cooling)]\\\\n\\\\t\\\\t {\:type \:\:bee,\\\\n\\\\t\\\\t  \:start-cooling start-cooling\\\\n\\\\t\\\\t  \:stop-cooling stop-cooling\\\\n\\\\t\\\\t  \:start-heating start-heating\\\\n\\\\t\\\\t  \:stop-heating stop-heating\\\\n\\\\t\\\\t  \:delta-temp delta-temp\\\\n\\\\t\\\\t  \:previous-action (atom \:\:none)}))]\\\\n    (swap\! *bees* (fn [atom] bees))\\\\n    bees))\\\\n\\\\n(defn bee-action [bee temperature]\\\\n  (let [previous-action (\:previous-action bee)\\\\n\\\\tprevious-action-value @previous-action]\\\\n    ;; Using this function bees cannot transition directly from\\\\n    ;; heating to cooling and vice versa.  Not sure whether this is correct.\\\\n    (cond (\= previous-action-value \:\:cooling)\\\\n\\\\t  (if (< temperature (\:stop-cooling bee))\\\\n\\\\t    (do\\\\n\\\\t      (swap\! previous-action (fn [action] \:\:none))\\\\n\\\\t      0.0)\\\\n\\\\t    (- (\:delta-temp bee)))\\\\n\\\\t  (\= previous-action-value \:\:heating)\\\\n\\\\t  (if (> temperature (\:stop-heating bee))\\\\n\\\\t    (do\\\\n\\\\t      (swap\! previous-action (fn [action] \:\:none))\\\\n\\\\t      0.0)\\\\n\\\\t    (\:delta-temp bee))\\\\n\\\\t  (\= previous-action-value \:\:none)\\\\n\\\\t  (cond (>\= temperature (\:start-cooling bee))\\\\n\\\\t\\\\t(do\\\\n\\\\t\\\\t  (swap\! previous-action (fn [action] \:\:cooling))\\\\n\\\\t\\\\t  (- (\:delta-temp bee)))\\\\n\\\\t\\\\t(<\= temperature (\:start-heating bee))\\\\n\\\\t\\\\t(do\\\\n\\\\t\\\\t  (swap\! previous-action (fn [action] \:\:heating))\\\\n\\\\t\\\\t  (\:delta-temp bee))\\\\n\\\\t\\\\t\:else 0.0))))\\\\n\\\\n\\\\n(defn bee-actions [bees temperature]\\\\n  (sum (map \#(bee-action % temperature) bees)))\\\\n\\\\n(defn with-offset\\\\n  ([sequence]\\\\n     (cons (first sequence) sequence))\\\\n  ([sequence n]\\\\n     (if (zero? n)\\\\n       sequence\\\\n       (recur (with-offset sequence) (- n 1)))))\\\\n\\\\n(defn time-seq [example]\\\\n  (range 0 (\:end-time example)  (\:time-step example)))\\\\n\\\\n(defn delta-t-seq [external-temperature-seq]\\\\n  (map - external-temperature-seq (with-offset external-temperature-seq)))\\\\n\\\\n(defn result-temperatures [current-t delta-t-env bees]\\\\n  (let [current-delta-t-env (first delta-t-env)\\\\n\\\\tcurrent-delta-t-bees (bee-actions bees current-t)\\\\n\\\\tnext-t (+ current-t current-delta-t-env current-delta-t-bees)]\\\\n    ;; (println [current-t current-delta-t-env current-delta-t-bees])\\\\n    (lazy-seq\\\\n     (cons current-t\\\\n\\\\t   (let [new-delta-t-env (rest delta-t-env)]\\\\n\\\\t\\\\t (if (seq new-delta-t-env)\\\\n\\\\t\\\\t   (result-temperatures next-t new-delta-t-env bees)\\\\n\\\\t\\\\t   []))))))\\\\n\\\\n(defn plot-result [& {\:keys {example\\\\n\\\\t\\\\t\\\\t     times\\\\n\\\\t\\\\t\\\\t     temperatures\\\\n\\\\t\\\\t\\\\t     title}}]\\\\n  (let [example (or example $default-example)\\\\n        times (or times (time-seq example))\\\\n        temperatures (or temperatures (map external-temperature times))\\\\n\\\\ttitle (or title (\:title example) \\\\\\"Temperature Plot\\\\\\")]\\\\n    (xy-plot times temperatures\\\\n     \\\\t     \:title title \\\\n     \\\\t     \:x-label \\\\\\"Time (min)\\\\\\" \:y-label \\\\\\"Temperature (\u00AC\u221EC)\\\\\\")))\\\\n\\\\n(defn run-example [example]\\\\n  (let [time (time-seq example)\\\\n\\\\ttemp (map external-temperature time)\\\\n\\\\tplot (plot-result \:example example \:time time \:temperature temp)\\\\n\\\\tbees (make-bees example)\\\\n\\\\tdelta-t-env  (delta-t-seq temp)\\\\n\\\\tresult-temp (result-temperatures 0.0 delta-t-env bees)]\\\\n    ;; (println delta-t-env)\\\\n    ;; (println result-temp)\\\\n    (add-lines plot time result-temp)\\\\n    (view plot)))\\\\n\\\\n(defn -main [& args]\\\\n  (run-example $default-example)\\\\n  (run-example $fixed-example))\\\\n\\") \\"/Users/tc/Prog/Clojure/Projects/bee-algorithms/src/beeAlgorithms/core.clj\\" \\"/Users/tc/Prog/Clojure/Projects/bee-algorithms/src\\")" ";; Loading file src/beeAlgorithms/core.clj" "(clojure.lang.Compiler/load (java.io.StringReader. \\"(ns beeAlgorithms.core\\\\n  (\:gen-class)\\\\n  (\:use (incanter core stats charts\\\\n\\\\t\\\\t  [distributions \:exclude [variance mean]])))\\\\n\\\\n\\\\n(def *number-of-bees* 100)\\\\n(def *end-time* 120)\\\\n(def *time-step* 1)\\\\n\\\\n(defn make-example [& {\:keys [start-cooling-distribution\\\\n\\\\t\\\\t\\\\t      stop-cooling-distribution\\\\n\\\\t\\\\t\\\\t      number-of-bees\\\\n\\\\t\\\\t\\\\t      delta-temp\\\\n\\\\t\\\\t\\\\t      end-time\\\\n\\\\t\\\\t\\\\t      time-step\\\\n\\\\t\\\\t\\\\t      title],\\\\n\\\\t\\\\t       \:or {start-cooling-distribution (normal-distribution 2.0 1.0),\\\\n\\\\t\\\\t\\\\t    stop-cooling-distribution (normal-distribution 0.0 0.1),\\\\n\\\\t\\\\t\\\\t    number-of-bees *number-of-bees*,\\\\n\\\\t\\\\t\\\\t    delta-temp (/ 1 *number-of-bees*)\\\\n\\\\t\\\\t\\\\t    end-time *end-time*\\\\n\\\\t\\\\t\\\\t    time-step *time-step*\\\\n\\\\t\\\\t\\\\t    title \\\\\\"Unnamed Example\\\\\\"}}]\\\\n  {\:start-cooling-disribution start-cooling-distribution,\\\\n   \:stop-cooling-distribution stop-cooling-distribution,\\\\n   \:number-of-bees number-of-bees\\\\n   \:delta-temp delta-temp\\\\n   \:end-time end-time\\\\n   \:time-step time-step\\\\n   \:title title})\\\\n\\\\n(def $default-example (make-example \:start-cooling-disribution (normal-distribution 1.0 0.5)\\\\n\\\\t\\\\t\\\\t\\\\t    \:stop-cooling-distribution (normal-distribution 0.5 0.1)\\\\n\\\\t\\\\t\\\\t\\\\t    \:number-of-bees *number-of-bees*\\\\n\\\\t\\\\t\\\\t\\\\t    \:delta-temp (/ 1 *number-of-bees*)\\\\n\\\\t\\\\t\\\\t\\\\t    \:title \\\\\\"Normally Distributed Default Example\\\\\\"))\\\\n\\\\n(def $fixed-example (make-example \:start-cooling-disribution [1.0]\\\\n\\\\t\\\\t\\\\t\\\\t  \:stop-cooling-distribution [0.5]\\\\n\\\\t\\\\t\\\\t\\\\t  \:number-of-bees *number-of-bees*\\\\n\\\\t\\\\t\\\\t\\\\t  \:delta-temp (/ 1 *number-of-bees*)\\\\n\\\\t\\\\t\\\\t\\\\t  \:title \\\\\\"Fixed Distribution\\\\\\"))\\\\n(def $pi java.lang.Math/PI)\\\\n\\\\n(defn sin-1 [x]\\\\n  (if (< x 0)\\\\n    0.0\\\\n    (let [scaled-x (/ x 2)]\\\\n      (sin scaled-x))))\\\\n\\\\n(defn accelerated-sin-2 [x]\\\\n  (if (< x 0)\\\\n    0.0\\\\n    (let [scaled-x (/ x $pi 10.0)]\\\\n      (sin (* $pi scaled-x scaled-x)))))\\\\n\\\\n(defn accelerated-sin-3 [x]\\\\n  (if (< x 0)\\\\n    0.0\\\\n    (let [scaled-x (/ x $pi 10.0)]\\\\n      (sin (* 0.3 $pi scaled-x scaled-x scaled-x)))))\\\\n\\\\n(defn accelerated-sin-exp [x]\\\\n  (if (< x 0)\\\\n    0.0\\\\n    (let [scaled-x (/ x $pi 10)]\\\\n      (sin (- (exp scaled-x) 1)))))\\\\n\\\\n(defn make-external-temperature-fun [max driver-fun]\\\\n  (fn [t]\\\\n    (* max (driver-fun t))))\\\\n\\\\n(def external-temperature\\\\n     (make-external-temperature-fun 5.0 accelerated-sin-exp))\\\\n\\\\n(def *bees* (atom []))\\\\n\\\\n(defn make-bees [example]\\\\n  (let [start-cooling-distribution (\:start-cooling-disribution example)\\\\n\\\\tstop-cooling-distribution (\:stop-cooling-distribution example)\\\\n\\\\tnumber-of-bees (\:number-of-bees example)\\\\n\\\\tdelta-temp (\:delta-temp example)\\\\n\\\\tbees (for [i (range number-of-bees)]\\\\n\\\\t       (let [start-cooling (abs (draw start-cooling-distribution))\\\\n\\\\t\\\\t     stop-cooling (min (draw stop-cooling-distribution) (- start-cooling 0.5))\\\\n\\\\t\\\\t     start-heating (- start-cooling)\\\\n\\\\t\\\\t     stop-heating (- stop-cooling)]\\\\n\\\\t\\\\t {\:type \:\:bee,\\\\n\\\\t\\\\t  \:start-cooling start-cooling\\\\n\\\\t\\\\t  \:stop-cooling stop-cooling\\\\n\\\\t\\\\t  \:start-heating start-heating\\\\n\\\\t\\\\t  \:stop-heating stop-heating\\\\n\\\\t\\\\t  \:delta-temp delta-temp\\\\n\\\\t\\\\t  \:previous-action (atom \:\:none)}))]\\\\n    (swap\! *bees* (fn [atom] bees))\\\\n    bees))\\\\n\\\\n(defn bee-action [bee temperature]\\\\n  (let [previous-action (\:previous-action bee)\\\\n\\\\tprevious-action-value @previous-action]\\\\n    ;; Using this function bees cannot transition directly from\\\\n    ;; heating to cooling and vice versa.  Not sure whether this is correct.\\\\n    (cond (\= previous-action-value \:\:cooling)\\\\n\\\\t  (if (< temperature (\:stop-cooling bee))\\\\n\\\\t    (do\\\\n\\\\t      (swap\! previous-action (fn [action] \:\:none))\\\\n\\\\t      0.0)\\\\n\\\\t    (- (\:delta-temp bee)))\\\\n\\\\t  (\= previous-action-value \:\:heating)\\\\n\\\\t  (if (> temperature (\:stop-heating bee))\\\\n\\\\t    (do\\\\n\\\\t      (swap\! previous-action (fn [action] \:\:none))\\\\n\\\\t      0.0)\\\\n\\\\t    (\:delta-temp bee))\\\\n\\\\t  (\= previous-action-value \:\:none)\\\\n\\\\t  (cond (>\= temperature (\:start-cooling bee))\\\\n\\\\t\\\\t(do\\\\n\\\\t\\\\t  (swap\! previous-action (fn [action] \:\:cooling))\\\\n\\\\t\\\\t  (- (\:delta-temp bee)))\\\\n\\\\t\\\\t(<\= temperature (\:start-heating bee))\\\\n\\\\t\\\\t(do\\\\n\\\\t\\\\t  (swap\! previous-action (fn [action] \:\:heating))\\\\n\\\\t\\\\t  (\:delta-temp bee))\\\\n\\\\t\\\\t\:else 0.0))))\\\\n\\\\n\\\\n(defn bee-actions [bees temperature]\\\\n  (sum (map \#(bee-action % temperature) bees)))\\\\n\\\\n(defn with-offset\\\\n  ([sequence]\\\\n     (cons (first sequence) sequence))\\\\n  ([sequence n]\\\\n     (if (zero? n)\\\\n       sequence\\\\n       (recur (with-offset sequence) (- n 1)))))\\\\n\\\\n(defn time-seq [example]\\\\n  (range 0 (\:end-time example)  (\:time-step example)))\\\\n\\\\n(defn delta-t-seq [external-temperature-seq]\\\\n  (map - external-temperature-seq (with-offset external-temperature-seq)))\\\\n\\\\n(defn result-temperatures [current-t delta-t-env bees]\\\\n  (let [current-delta-t-env (first delta-t-env)\\\\n\\\\tcurrent-delta-t-bees (bee-actions bees current-t)\\\\n\\\\tnext-t (+ current-t current-delta-t-env current-delta-t-bees)]\\\\n    ;; (println [current-t current-delta-t-env current-delta-t-bees])\\\\n    (lazy-seq\\\\n     (cons current-t\\\\n\\\\t   (let [new-delta-t-env (rest delta-t-env)]\\\\n\\\\t\\\\t (if (seq new-delta-t-env)\\\\n\\\\t\\\\t   (result-temperatures next-t new-delta-t-env bees)\\\\n\\\\t\\\\t   []))))))\\\\n\\\\n(defn plot-result [& {\:keys {example\\\\n\\\\t\\\\t\\\\t     times\\\\n\\\\t\\\\t\\\\t     temperatures\\\\n\\\\t\\\\t\\\\t     title}}]\\\\n  (let [example (or example $default-example)\\\\n        times (or times (time-seq example))\\\\n        temperatures (or temperatures (map external-temperature times))\\\\n\\\\ttitle (or title (\:title example) \\\\\\"Temperature Plot\\\\\\")]\\\\n    (xy-plot times temperatures\\\\n     \\\\t     \:title title \\\\n     \\\\t     \:x-label \\\\\\"Time (min)\\\\\\" \:y-label \\\\\\"Temperature (\u00AC\u221EC)\\\\\\")))\\\\n\\\\n(defn run-example [example]\\\\n  (let [time (time-seq example)\\\\n\\\\ttemp (map external-temperature time)\\\\n\\\\tplot (plot-result \:example example \:time time \:temperature temp)\\\\n\\\\tbees (make-bees example)\\\\n\\\\tdelta-t-env  (delta-t-seq temp)\\\\n\\\\tresult-temp (result-temperatures 0.0 delta-t-env bees)]\\\\n    ;; (println delta-t-env)\\\\n    ;; (println result-temp)\\\\n    (add-lines plot time result-temp)\\\\n    (view plot)))\\\\n\\\\n(defn -main [& args]\\\\n  (run-example $default-example)\\\\n  (run-example $fixed-example))\\\\n\\") \\"/Users/tc/Prog/Clojure/Projects/bee-algorithms/src/beeAlgorithms/core.clj\\" \\"/Users/tc/Prog/Clojure/Projects/bee-algorithms/src\\")" "(-main)" ";; Switching to beeAlgorithms.core namespace" "(clojure.core/in-ns 'beeAlgorithms.core)" ";; Loading file src/beeAlgorithms/core.clj" "(clojure.lang.Compiler/load (java.io.StringReader. \\"(ns beeAlgorithms.core\\\\n  (\:gen-class)\\\\n  (\:use (incanter core stats charts\\\\n\\\\t\\\\t  [distributions \:exclude [variance mean]])))\\\\n\\\\n\\\\n(def *number-of-bees* 100)\\\\n(def *end-time* 120)\\\\n(def *time-step* 1)\\\\n\\\\n(defn make-example [& {\:keys [start-cooling-distribution\\\\n\\\\t\\\\t\\\\t      stop-cooling-distribution\\\\n\\\\t\\\\t\\\\t      number-of-bees\\\\n\\\\t\\\\t\\\\t      delta-temp\\\\n\\\\t\\\\t\\\\t      end-time\\\\n\\\\t\\\\t\\\\t      time-step\\\\n\\\\t\\\\t\\\\t      title],\\\\n\\\\t\\\\t       \:or {start-cooling-distribution (normal-distribution 2.0 1.0),\\\\n\\\\t\\\\t\\\\t    stop-cooling-distribution (normal-distribution 0.0 0.1),\\\\n\\\\t\\\\t\\\\t    number-of-bees *number-of-bees*,\\\\n\\\\t\\\\t\\\\t    delta-temp (/ 1 *number-of-bees*)\\\\n\\\\t\\\\t\\\\t    end-time *end-time*\\\\n\\\\t\\\\t\\\\t    time-step *time-step*\\\\n\\\\t\\\\t\\\\t    title \\\\\\"Unnamed Example\\\\\\"}}]\\\\n  {\:start-cooling-disribution start-cooling-distribution,\\\\n   \:stop-cooling-distribution stop-cooling-distribution,\\\\n   \:number-of-bees number-of-bees\\\\n   \:delta-temp delta-temp\\\\n   \:end-time end-time\\\\n   \:time-step time-step\\\\n   \:title title})\\\\n\\\\n(def $default-example (make-example \:start-cooling-disribution (normal-distribution 1.0 0.5)\\\\n\\\\t\\\\t\\\\t\\\\t    \:stop-cooling-distribution (normal-distribution 0.5 0.1)\\\\n\\\\t\\\\t\\\\t\\\\t    \:number-of-bees *number-of-bees*\\\\n\\\\t\\\\t\\\\t\\\\t    \:delta-temp (/ 1 *number-of-bees*)\\\\n\\\\t\\\\t\\\\t\\\\t    \:title \\\\\\"Normally Distributed Default Example\\\\\\"))\\\\n\\\\n(def $fixed-example (make-example \:start-cooling-disribution [1.0]\\\\n\\\\t\\\\t\\\\t\\\\t  \:stop-cooling-distribution [0.5]\\\\n\\\\t\\\\t\\\\t\\\\t  \:number-of-bees *number-of-bees*\\\\n\\\\t\\\\t\\\\t\\\\t  \:delta-temp (/ 1 *number-of-bees*)\\\\n\\\\t\\\\t\\\\t\\\\t  \:title \\\\\\"Fixed Distribution\\\\\\"))\\\\n(def $pi java.lang.Math/PI)\\\\n\\\\n(defn sin-1 [x]\\\\n  (if (< x 0)\\\\n    0.0\\\\n    (let [scaled-x (/ x 2)]\\\\n      (sin scaled-x))))\\\\n\\\\n(defn accelerated-sin-2 [x]\\\\n  (if (< x 0)\\\\n    0.0\\\\n    (let [scaled-x (/ x $pi 10.0)]\\\\n      (sin (* $pi scaled-x scaled-x)))))\\\\n\\\\n(defn accelerated-sin-3 [x]\\\\n  (if (< x 0)\\\\n    0.0\\\\n    (let [scaled-x (/ x $pi 10.0)]\\\\n      (sin (* 0.3 $pi scaled-x scaled-x scaled-x)))))\\\\n\\\\n(defn accelerated-sin-exp [x]\\\\n  (if (< x 0)\\\\n    0.0\\\\n    (let [scaled-x (/ x $pi 10)]\\\\n      (sin (- (exp scaled-x) 1)))))\\\\n\\\\n(defn make-external-temperature-fun [max driver-fun]\\\\n  (fn [t]\\\\n    (* max (driver-fun t))))\\\\n\\\\n(def external-temperature\\\\n     (make-external-temperature-fun 5.0 accelerated-sin-exp))\\\\n\\\\n(def *bees* (atom []))\\\\n\\\\n(defn make-bees [example]\\\\n  (let [start-cooling-distribution (\:start-cooling-disribution example)\\\\n\\\\tstop-cooling-distribution (\:stop-cooling-distribution example)\\\\n\\\\tnumber-of-bees (\:number-of-bees example)\\\\n\\\\tdelta-temp (\:delta-temp example)\\\\n\\\\tbees (for [i (range number-of-bees)]\\\\n\\\\t       (let [start-cooling (abs (draw start-cooling-distribution))\\\\n\\\\t\\\\t     stop-cooling (min (draw stop-cooling-distribution) (- start-cooling 0.5))\\\\n\\\\t\\\\t     start-heating (- start-cooling)\\\\n\\\\t\\\\t     stop-heating (- stop-cooling)]\\\\n\\\\t\\\\t {\:type \:\:bee,\\\\n\\\\t\\\\t  \:start-cooling start-cooling\\\\n\\\\t\\\\t  \:stop-cooling stop-cooling\\\\n\\\\t\\\\t  \:start-heating start-heating\\\\n\\\\t\\\\t  \:stop-heating stop-heating\\\\n\\\\t\\\\t  \:delta-temp delta-temp\\\\n\\\\t\\\\t  \:previous-action (atom \:\:none)}))]\\\\n    (swap\! *bees* (fn [atom] bees))\\\\n    bees))\\\\n\\\\n(defn bee-action [bee temperature]\\\\n  (let [previous-action (\:previous-action bee)\\\\n\\\\tprevious-action-value @previous-action]\\\\n    ;; Using this function bees cannot transition directly from\\\\n    ;; heating to cooling and vice versa.  Not sure whether this is correct.\\\\n    (cond (\= previous-action-value \:\:cooling)\\\\n\\\\t  (if (< temperature (\:stop-cooling bee))\\\\n\\\\t    (do\\\\n\\\\t      (swap\! previous-action (fn [action] \:\:none))\\\\n\\\\t      0.0)\\\\n\\\\t    (- (\:delta-temp bee)))\\\\n\\\\t  (\= previous-action-value \:\:heating)\\\\n\\\\t  (if (> temperature (\:stop-heating bee))\\\\n\\\\t    (do\\\\n\\\\t      (swap\! previous-action (fn [action] \:\:none))\\\\n\\\\t      0.0)\\\\n\\\\t    (\:delta-temp bee))\\\\n\\\\t  (\= previous-action-value \:\:none)\\\\n\\\\t  (cond (>\= temperature (\:start-cooling bee))\\\\n\\\\t\\\\t(do\\\\n\\\\t\\\\t  (swap\! previous-action (fn [action] \:\:cooling))\\\\n\\\\t\\\\t  (- (\:delta-temp bee)))\\\\n\\\\t\\\\t(<\= temperature (\:start-heating bee))\\\\n\\\\t\\\\t(do\\\\n\\\\t\\\\t  (swap\! previous-action (fn [action] \:\:heating))\\\\n\\\\t\\\\t  (\:delta-temp bee))\\\\n\\\\t\\\\t\:else 0.0))))\\\\n\\\\n\\\\n(defn bee-actions [bees temperature]\\\\n  (sum (map \#(bee-action % temperature) bees)))\\\\n\\\\n(defn with-offset\\\\n  ([sequence]\\\\n     (cons (first sequence) sequence))\\\\n  ([sequence n]\\\\n     (if (zero? n)\\\\n       sequence\\\\n       (recur (with-offset sequence) (- n 1)))))\\\\n\\\\n(defn time-seq [example]\\\\n  (range 0 (\:end-time example)  (\:time-step example)))\\\\n\\\\n(defn delta-t-seq [external-temperature-seq]\\\\n  (map - external-temperature-seq (with-offset external-temperature-seq)))\\\\n\\\\n(defn result-temperatures [current-t delta-t-env bees]\\\\n  (let [current-delta-t-env (first delta-t-env)\\\\n\\\\tcurrent-delta-t-bees (bee-actions bees current-t)\\\\n\\\\tnext-t (+ current-t current-delta-t-env current-delta-t-bees)]\\\\n    ;; (println [current-t current-delta-t-env current-delta-t-bees])\\\\n    (lazy-seq\\\\n     (cons current-t\\\\n\\\\t   (let [new-delta-t-env (rest delta-t-env)]\\\\n\\\\t\\\\t (if (seq new-delta-t-env)\\\\n\\\\t\\\\t   (result-temperatures next-t new-delta-t-env bees)\\\\n\\\\t\\\\t   []))))))\\\\n\\\\n(defn plot-result [& {\:keys {example\\\\n\\\\t\\\\t\\\\t     times\\\\n\\\\t\\\\t\\\\t     temperatures\\\\n\\\\t\\\\t\\\\t     title}}]\\\\n  (let [example (or example $default-example)\\\\n        times (or times (time-seq example))\\\\n        temperatures (or temperatures (map external-temperature times))\\\\n\\\\ttitle (or title (\:title example) \\\\\\"Temperature Plot\\\\\\")]\\\\n    (xy-plot times temperatures\\\\n     \\\\t     \:title title \\\\n     \\\\t     \:x-label \\\\\\"Time (min)\\\\\\" \:y-label \\\\\\"Temperature (\u00AC\u221EC)\\\\\\")))\\\\n\\\\n(defn run-example [example]\\\\n  (let [time (time-seq example)\\\\n        temp (map external-temperature time)\\\\n        plot (plot-result \:example example \:time time \:temperature temp)\\\\n        bees (make-bees example)\\\\n        delta-t-env  (delta-t-seq temp)\\\\n        result-temp (result-temperatures 0.0 delta-t-env bees)]\\\\n    ;; (println delta-t-env)\\\\n    ;; (println result-temp)\\\\n    (add-lines plot time result-temp)\\\\n    (view plot)))\\\\n\\\\n(defn -main [& args]\\\\n  (run-example $default-example)\\\\n  (run-example $fixed-example))\\\\n\\") \\"/Users/tc/Prog/Clojure/Projects/bee-algorithms/src/beeAlgorithms/core.clj\\" \\"/Users/tc/Prog/Clojure/Projects/bee-algorithms/src\\")" "(-main)" ";; Loading file src/beeAlgorithms/core.clj" "(clojure.lang.Compiler/load (java.io.StringReader. \\"(ns beeAlgorithms.core\\\\n  (\:gen-class)\\\\n  (\:use (incanter core stats charts\\\\n\\\\t\\\\t  [distributions \:exclude [variance mean]])))\\\\n\\\\n\\\\n(def *number-of-bees* 100)\\\\n(def *end-time* 120)\\\\n(def *time-step* 1)\\\\n\\\\n(defn make-example [& {\:keys [start-cooling-distribution\\\\n\\\\t\\\\t\\\\t      stop-cooling-distribution\\\\n\\\\t\\\\t\\\\t      number-of-bees\\\\n\\\\t\\\\t\\\\t      delta-temp\\\\n\\\\t\\\\t\\\\t      end-time\\\\n\\\\t\\\\t\\\\t      time-step\\\\n\\\\t\\\\t\\\\t      title],\\\\n\\\\t\\\\t       \:or {start-cooling-distribution (normal-distribution 2.0 1.0),\\\\n\\\\t\\\\t\\\\t    stop-cooling-distribution (normal-distribution 0.0 0.1),\\\\n\\\\t\\\\t\\\\t    number-of-bees *number-of-bees*,\\\\n\\\\t\\\\t\\\\t    delta-temp (/ 1 *number-of-bees*)\\\\n\\\\t\\\\t\\\\t    end-time *end-time*\\\\n\\\\t\\\\t\\\\t    time-step *time-step*\\\\n\\\\t\\\\t\\\\t    title \\\\\\"Unnamed Example\\\\\\"}}]\\\\n  {\:start-cooling-disribution start-cooling-distribution,\\\\n   \:stop-cooling-distribution stop-cooling-distribution,\\\\n   \:number-of-bees number-of-bees\\\\n   \:delta-temp delta-temp\\\\n   \:end-time end-time\\\\n   \:time-step time-step\\\\n   \:title title})\\\\n\\\\n(def $default-example (make-example \:start-cooling-disribution (normal-distribution 1.0 0.5)\\\\n\\\\t\\\\t\\\\t\\\\t    \:stop-cooling-distribution (normal-distribution 0.5 0.1)\\\\n\\\\t\\\\t\\\\t\\\\t    \:number-of-bees *number-of-bees*\\\\n\\\\t\\\\t\\\\t\\\\t    \:delta-temp (/ 1 *number-of-bees*)\\\\n\\\\t\\\\t\\\\t\\\\t    \:title \\\\\\"Normally Distributed Default Example\\\\\\"))\\\\n\\\\n(def $fixed-example (make-example \:start-cooling-disribution [1.0]\\\\n\\\\t\\\\t\\\\t\\\\t  \:stop-cooling-distribution [0.5]\\\\n\\\\t\\\\t\\\\t\\\\t  \:number-of-bees *number-of-bees*\\\\n\\\\t\\\\t\\\\t\\\\t  \:delta-temp (/ 1 *number-of-bees*)\\\\n\\\\t\\\\t\\\\t\\\\t  \:title \\\\\\"Fixed Distribution\\\\\\"))\\\\n(def $pi java.lang.Math/PI)\\\\n\\\\n(defn sin-1 [x]\\\\n  (if (< x 0)\\\\n    0.0\\\\n    (let [scaled-x (/ x 2)]\\\\n      (sin scaled-x))))\\\\n\\\\n(defn accelerated-sin-2 [x]\\\\n  (if (< x 0)\\\\n    0.0\\\\n    (let [scaled-x (/ x $pi 10.0)]\\\\n      (sin (* $pi scaled-x scaled-x)))))\\\\n\\\\n(defn accelerated-sin-3 [x]\\\\n  (if (< x 0)\\\\n    0.0\\\\n    (let [scaled-x (/ x $pi 10.0)]\\\\n      (sin (* 0.3 $pi scaled-x scaled-x scaled-x)))))\\\\n\\\\n(defn accelerated-sin-exp [x]\\\\n  (if (< x 0)\\\\n    0.0\\\\n    (let [scaled-x (/ x $pi 10)]\\\\n      (sin (- (exp scaled-x) 1)))))\\\\n\\\\n(defn make-external-temperature-fun [max driver-fun]\\\\n  (fn [t]\\\\n    (* max (driver-fun t))))\\\\n\\\\n(def external-temperature\\\\n     (make-external-temperature-fun 5.0 accelerated-sin-exp))\\\\n\\\\n(def *bees* (atom []))\\\\n\\\\n(defn make-bees [example]\\\\n  (let [start-cooling-distribution (\:start-cooling-disribution example)\\\\n\\\\tstop-cooling-distribution (\:stop-cooling-distribution example)\\\\n\\\\tnumber-of-bees (\:number-of-bees example)\\\\n\\\\tdelta-temp (\:delta-temp example)\\\\n\\\\tbees (for [i (range number-of-bees)]\\\\n\\\\t       (let [start-cooling (abs (draw start-cooling-distribution))\\\\n\\\\t\\\\t     stop-cooling (min (draw stop-cooling-distribution) (- start-cooling 0.5))\\\\n\\\\t\\\\t     start-heating (- start-cooling)\\\\n\\\\t\\\\t     stop-heating (- stop-cooling)]\\\\n\\\\t\\\\t {\:type \:\:bee,\\\\n\\\\t\\\\t  \:start-cooling start-cooling\\\\n\\\\t\\\\t  \:stop-cooling stop-cooling\\\\n\\\\t\\\\t  \:start-heating start-heating\\\\n\\\\t\\\\t  \:stop-heating stop-heating\\\\n\\\\t\\\\t  \:delta-temp delta-temp\\\\n\\\\t\\\\t  \:previous-action (atom \:\:none)}))]\\\\n    (swap\! *bees* (fn [atom] bees))\\\\n    bees))\\\\n\\\\n(defn bee-action [bee temperature]\\\\n  (let [previous-action (\:previous-action bee)\\\\n\\\\tprevious-action-value @previous-action]\\\\n    ;; Using this function bees cannot transition directly from\\\\n    ;; heating to cooling and vice versa.  Not sure whether this is correct.\\\\n    (cond (\= previous-action-value \:\:cooling)\\\\n\\\\t  (if (< temperature (\:stop-cooling bee))\\\\n\\\\t    (do\\\\n\\\\t      (swap\! previous-action (fn [action] \:\:none))\\\\n\\\\t      0.0)\\\\n\\\\t    (- (\:delta-temp bee)))\\\\n\\\\t  (\= previous-action-value \:\:heating)\\\\n\\\\t  (if (> temperature (\:stop-heating bee))\\\\n\\\\t    (do\\\\n\\\\t      (swap\! previous-action (fn [action] \:\:none))\\\\n\\\\t      0.0)\\\\n\\\\t    (\:delta-temp bee))\\\\n\\\\t  (\= previous-action-value \:\:none)\\\\n\\\\t  (cond (>\= temperature (\:start-cooling bee))\\\\n\\\\t\\\\t(do\\\\n\\\\t\\\\t  (swap\! previous-action (fn [action] \:\:cooling))\\\\n\\\\t\\\\t  (- (\:delta-temp bee)))\\\\n\\\\t\\\\t(<\= temperature (\:start-heating bee))\\\\n\\\\t\\\\t(do\\\\n\\\\t\\\\t  (swap\! previous-action (fn [action] \:\:heating))\\\\n\\\\t\\\\t  (\:delta-temp bee))\\\\n\\\\t\\\\t\:else 0.0))))\\\\n\\\\n\\\\n(defn bee-actions [bees temperature]\\\\n  (sum (map \#(bee-action % temperature) bees)))\\\\n\\\\n(defn with-offset\\\\n  ([sequence]\\\\n     (cons (first sequence) sequence))\\\\n  ([sequence n]\\\\n     (if (zero? n)\\\\n       sequence\\\\n       (recur (with-offset sequence) (- n 1)))))\\\\n\\\\n(defn time-seq [example]\\\\n  (range 0 (\:end-time example)  (\:time-step example)))\\\\n\\\\n(defn delta-t-seq [external-temperature-seq]\\\\n  (map - external-temperature-seq (with-offset external-temperature-seq)))\\\\n\\\\n(defn result-temperatures [current-t delta-t-env bees]\\\\n  (let [current-delta-t-env (first delta-t-env)\\\\n\\\\tcurrent-delta-t-bees (bee-actions bees current-t)\\\\n\\\\tnext-t (+ current-t current-delta-t-env current-delta-t-bees)]\\\\n    ;; (println [current-t current-delta-t-env current-delta-t-bees])\\\\n    (lazy-seq\\\\n     (cons current-t\\\\n\\\\t   (let [new-delta-t-env (rest delta-t-env)]\\\\n\\\\t\\\\t (if (seq new-delta-t-env)\\\\n\\\\t\\\\t   (result-temperatures next-t new-delta-t-env bees)\\\\n\\\\t\\\\t   []))))))\\\\n\\\\n(defn plot-result [& {\:keys {example\\\\n                             times\\\\n                             temperatures\\\\n                             title}}]\\\\n  (let [example (or example $default-example)\\\\n        times (or times (time-seq example))\\\\n        temperatures (or temperatures (\:temperatures example))\\\\n\\\\ttitle (or title (\:title example) \\\\\\"Temperature Plot\\\\\\")]\\\\n    (xy-plot times temperatures\\\\n     \\\\t     \:title title \\\\n     \\\\t     \:x-label \\\\\\"Time (min)\\\\\\" \:y-label \\\\\\"Temperature (\u00AC\u221EC)\\\\\\")))\\\\n\\\\n(defn run-example [example]\\\\n  (let [plot (plot-result \:example example)\\\\n        bees (make-bees example)\\\\n        delta-t-env  (delta-t-seq (\:temperatures example)\\\\n        result-temp (result-temperatures 0.0 delta-t-env bees)]\\\\n    ;; (println delta-t-env)\\\\n    ;; (println result-temp)\\\\n    (add-lines plot time result-temp)\\\\n    (view plot)))\\\\n\\\\n(defn -main [& args]\\\\n  (run-example $default-example)\\\\n  (run-example $fixed-example))\\\\n\\") \\"/Users/tc/Prog/Clojure/Projects/bee-algorithms/src/beeAlgorithms/core.clj\\" \\"/Users/tc/Prog/Clojure/Projects/bee-algorithms/src\\")" ";; Loading file src/beeAlgorithms/core.clj" "(clojure.lang.Compiler/load (java.io.StringReader. \\"(ns beeAlgorithms.core\\\\n  (\:gen-class)\\\\n  (\:use (incanter core stats charts\\\\n\\\\t\\\\t  [distributions \:exclude [variance mean]])))\\\\n\\\\n\\\\n(def *number-of-bees* 100)\\\\n(def *end-time* 120)\\\\n(def *time-step* 1)\\\\n\\\\n(defn make-example [& {\:keys [start-cooling-distribution\\\\n\\\\t\\\\t\\\\t      stop-cooling-distribution\\\\n\\\\t\\\\t\\\\t      number-of-bees\\\\n\\\\t\\\\t\\\\t      delta-temp\\\\n\\\\t\\\\t\\\\t      end-time\\\\n\\\\t\\\\t\\\\t      time-step\\\\n\\\\t\\\\t\\\\t      title],\\\\n\\\\t\\\\t       \:or {start-cooling-distribution (normal-distribution 2.0 1.0),\\\\n\\\\t\\\\t\\\\t    stop-cooling-distribution (normal-distribution 0.0 0.1),\\\\n\\\\t\\\\t\\\\t    number-of-bees *number-of-bees*,\\\\n\\\\t\\\\t\\\\t    delta-temp (/ 1 *number-of-bees*)\\\\n\\\\t\\\\t\\\\t    end-time *end-time*\\\\n\\\\t\\\\t\\\\t    time-step *time-step*\\\\n\\\\t\\\\t\\\\t    title \\\\\\"Unnamed Example\\\\\\"}}]\\\\n  {\:start-cooling-disribution start-cooling-distribution,\\\\n   \:stop-cooling-distribution stop-cooling-distribution,\\\\n   \:number-of-bees number-of-bees\\\\n   \:delta-temp delta-temp\\\\n   \:end-time end-time\\\\n   \:time-step time-step\\\\n   \:title title})\\\\n\\\\n(def $default-example (make-example \:start-cooling-disribution (normal-distribution 1.0 0.5)\\\\n\\\\t\\\\t\\\\t\\\\t    \:stop-cooling-distribution (normal-distribution 0.5 0.1)\\\\n\\\\t\\\\t\\\\t\\\\t    \:number-of-bees *number-of-bees*\\\\n\\\\t\\\\t\\\\t\\\\t    \:delta-temp (/ 1 *number-of-bees*)\\\\n\\\\t\\\\t\\\\t\\\\t    \:title \\\\\\"Normally Distributed Default Example\\\\\\"))\\\\n\\\\n(def $fixed-example (make-example \:start-cooling-disribution [1.0]\\\\n\\\\t\\\\t\\\\t\\\\t  \:stop-cooling-distribution [0.5]\\\\n\\\\t\\\\t\\\\t\\\\t  \:number-of-bees *number-of-bees*\\\\n\\\\t\\\\t\\\\t\\\\t  \:delta-temp (/ 1 *number-of-bees*)\\\\n\\\\t\\\\t\\\\t\\\\t  \:title \\\\\\"Fixed Distribution\\\\\\"))\\\\n(def $pi java.lang.Math/PI)\\\\n\\\\n(defn sin-1 [x]\\\\n  (if (< x 0)\\\\n    0.0\\\\n    (let [scaled-x (/ x 2)]\\\\n      (sin scaled-x))))\\\\n\\\\n(defn accelerated-sin-2 [x]\\\\n  (if (< x 0)\\\\n    0.0\\\\n    (let [scaled-x (/ x $pi 10.0)]\\\\n      (sin (* $pi scaled-x scaled-x)))))\\\\n\\\\n(defn accelerated-sin-3 [x]\\\\n  (if (< x 0)\\\\n    0.0\\\\n    (let [scaled-x (/ x $pi 10.0)]\\\\n      (sin (* 0.3 $pi scaled-x scaled-x scaled-x)))))\\\\n\\\\n(defn accelerated-sin-exp [x]\\\\n  (if (< x 0)\\\\n    0.0\\\\n    (let [scaled-x (/ x $pi 10)]\\\\n      (sin (- (exp scaled-x) 1)))))\\\\n\\\\n(defn make-external-temperature-fun [max driver-fun]\\\\n  (fn [t]\\\\n    (* max (driver-fun t))))\\\\n\\\\n(def external-temperature\\\\n     (make-external-temperature-fun 5.0 accelerated-sin-exp))\\\\n\\\\n(def *bees* (atom []))\\\\n\\\\n(defn make-bees [example]\\\\n  (let [start-cooling-distribution (\:start-cooling-disribution example)\\\\n\\\\tstop-cooling-distribution (\:stop-cooling-distribution example)\\\\n\\\\tnumber-of-bees (\:number-of-bees example)\\\\n\\\\tdelta-temp (\:delta-temp example)\\\\n\\\\tbees (for [i (range number-of-bees)]\\\\n\\\\t       (let [start-cooling (abs (draw start-cooling-distribution))\\\\n\\\\t\\\\t     stop-cooling (min (draw stop-cooling-distribution) (- start-cooling 0.5))\\\\n\\\\t\\\\t     start-heating (- start-cooling)\\\\n\\\\t\\\\t     stop-heating (- stop-cooling)]\\\\n\\\\t\\\\t {\:type \:\:bee,\\\\n\\\\t\\\\t  \:start-cooling start-cooling\\\\n\\\\t\\\\t  \:stop-cooling stop-cooling\\\\n\\\\t\\\\t  \:start-heating start-heating\\\\n\\\\t\\\\t  \:stop-heating stop-heating\\\\n\\\\t\\\\t  \:delta-temp delta-temp\\\\n\\\\t\\\\t  \:previous-action (atom \:\:none)}))]\\\\n    (swap\! *bees* (fn [atom] bees))\\\\n    bees))\\\\n\\\\n(defn bee-action [bee temperature]\\\\n  (let [previous-action (\:previous-action bee)\\\\n\\\\tprevious-action-value @previous-action]\\\\n    ;; Using this function bees cannot transition directly from\\\\n    ;; heating to cooling and vice versa.  Not sure whether this is correct.\\\\n    (cond (\= previous-action-value \:\:cooling)\\\\n\\\\t  (if (< temperature (\:stop-cooling bee))\\\\n\\\\t    (do\\\\n\\\\t      (swap\! previous-action (fn [action] \:\:none))\\\\n\\\\t      0.0)\\\\n\\\\t    (- (\:delta-temp bee)))\\\\n\\\\t  (\= previous-action-value \:\:heating)\\\\n\\\\t  (if (> temperature (\:stop-heating bee))\\\\n\\\\t    (do\\\\n\\\\t      (swap\! previous-action (fn [action] \:\:none))\\\\n\\\\t      0.0)\\\\n\\\\t    (\:delta-temp bee))\\\\n\\\\t  (\= previous-action-value \:\:none)\\\\n\\\\t  (cond (>\= temperature (\:start-cooling bee))\\\\n\\\\t\\\\t(do\\\\n\\\\t\\\\t  (swap\! previous-action (fn [action] \:\:cooling))\\\\n\\\\t\\\\t  (- (\:delta-temp bee)))\\\\n\\\\t\\\\t(<\= temperature (\:start-heating bee))\\\\n\\\\t\\\\t(do\\\\n\\\\t\\\\t  (swap\! previous-action (fn [action] \:\:heating))\\\\n\\\\t\\\\t  (\:delta-temp bee))\\\\n\\\\t\\\\t\:else 0.0))))\\\\n\\\\n\\\\n(defn bee-actions [bees temperature]\\\\n  (sum (map \#(bee-action % temperature) bees)))\\\\n\\\\n(defn with-offset\\\\n  ([sequence]\\\\n     (cons (first sequence) sequence))\\\\n  ([sequence n]\\\\n     (if (zero? n)\\\\n       sequence\\\\n       (recur (with-offset sequence) (- n 1)))))\\\\n\\\\n(defn time-seq [example]\\\\n  (range 0 (\:end-time example)  (\:time-step example)))\\\\n\\\\n(defn delta-t-seq [external-temperature-seq]\\\\n  (map - external-temperature-seq (with-offset external-temperature-seq)))\\\\n\\\\n(defn result-temperatures [current-t delta-t-env bees]\\\\n  (let [current-delta-t-env (first delta-t-env)\\\\n\\\\tcurrent-delta-t-bees (bee-actions bees current-t)\\\\n\\\\tnext-t (+ current-t current-delta-t-env current-delta-t-bees)]\\\\n    ;; (println [current-t current-delta-t-env current-delta-t-bees])\\\\n    (lazy-seq\\\\n     (cons current-t\\\\n\\\\t   (let [new-delta-t-env (rest delta-t-env)]\\\\n\\\\t\\\\t (if (seq new-delta-t-env)\\\\n\\\\t\\\\t   (result-temperatures next-t new-delta-t-env bees)\\\\n\\\\t\\\\t   []))))))\\\\n\\\\n(defn plot-result [& {\:keys {example\\\\n                             times\\\\n                             temperatures\\\\n                             title}}]\\\\n  (let [example (or example $default-example)\\\\n        times (or times (times example))\\\\n        temperatures (or temperatures (map external-temperature times))\\\\n        title (or title (\:title example))]\\\\n    (xy-plot times temperatures\\\\n     \\\\t     \:title title \\\\n     \\\\t     \:x-label \\\\\\"Time (min)\\\\\\" \:y-label \\\\\\"Temperature (\u00AC\u221EC)\\\\\\")))\\\\n\\\\n(defn run-example [example]\\\\n  (let [plot (plot-result \:example example)\\\\n        bees (make-bees example)\\\\n        delta-t-env  (delta-t-seq (\:temperatures example)\\\\n        result-temp (result-temperatures 0.0 delta-t-env bees)]\\\\n    ;; (println delta-t-env)\\\\n    ;; (println result-temp)\\\\n    (add-lines plot time result-temp)\\\\n    (view plot)))\\\\n\\\\n(defn -main [& args]\\\\n  (run-example $default-example)\\\\n  (run-example $fixed-example))\\\\n\\") \\"/Users/tc/Prog/Clojure/Projects/bee-algorithms/src/beeAlgorithms/core.clj\\" \\"/Users/tc/Prog/Clojure/Projects/bee-algorithms/src\\")" ";; Loading file src/beeAlgorithms/core.clj" "(clojure.lang.Compiler/load (java.io.StringReader. \\"(ns beeAlgorithms.core\\\\n  (\:gen-class)\\\\n  (\:use (incanter core stats charts\\\\n\\\\t\\\\t  [distributions \:exclude [variance mean]])))\\\\n\\\\n\\\\n(def *number-of-bees* 100)\\\\n(def *end-time* 120)\\\\n(def *time-step* 1)\\\\n\\\\n(defn make-example [& {\:keys [start-cooling-distribution\\\\n\\\\t\\\\t\\\\t      stop-cooling-distribution\\\\n\\\\t\\\\t\\\\t      number-of-bees\\\\n\\\\t\\\\t\\\\t      delta-temp\\\\n\\\\t\\\\t\\\\t      end-time\\\\n\\\\t\\\\t\\\\t      time-step\\\\n\\\\t\\\\t\\\\t      title],\\\\n\\\\t\\\\t       \:or {start-cooling-distribution (normal-distribution 2.0 1.0),\\\\n\\\\t\\\\t\\\\t    stop-cooling-distribution (normal-distribution 0.0 0.1),\\\\n\\\\t\\\\t\\\\t    number-of-bees *number-of-bees*,\\\\n\\\\t\\\\t\\\\t    delta-temp (/ 1 *number-of-bees*)\\\\n\\\\t\\\\t\\\\t    end-time *end-time*\\\\n\\\\t\\\\t\\\\t    time-step *time-step*\\\\n\\\\t\\\\t\\\\t    title \\\\\\"Unnamed Example\\\\\\"}}]\\\\n  {\:start-cooling-disribution start-cooling-distribution,\\\\n   \:stop-cooling-distribution stop-cooling-distribution,\\\\n   \:number-of-bees number-of-bees\\\\n   \:delta-temp delta-temp\\\\n   \:end-time end-time\\\\n   \:time-step time-step\\\\n   \:title title})\\\\n\\\\n(def $default-example (make-example \:start-cooling-disribution (normal-distribution 1.0 0.5)\\\\n\\\\t\\\\t\\\\t\\\\t    \:stop-cooling-distribution (normal-distribution 0.5 0.1)\\\\n\\\\t\\\\t\\\\t\\\\t    \:number-of-bees *number-of-bees*\\\\n\\\\t\\\\t\\\\t\\\\t    \:delta-temp (/ 1 *number-of-bees*)\\\\n\\\\t\\\\t\\\\t\\\\t    \:title \\\\\\"Normally Distributed Default Example\\\\\\"))\\\\n\\\\n(def $fixed-example (make-example \:start-cooling-disribution [1.0]\\\\n\\\\t\\\\t\\\\t\\\\t  \:stop-cooling-distribution [0.5]\\\\n\\\\t\\\\t\\\\t\\\\t  \:number-of-bees *number-of-bees*\\\\n\\\\t\\\\t\\\\t\\\\t  \:delta-temp (/ 1 *number-of-bees*)\\\\n\\\\t\\\\t\\\\t\\\\t  \:title \\\\\\"Fixed Distribution\\\\\\"))\\\\n(def $pi java.lang.Math/PI)\\\\n\\\\n(defn sin-1 [x]\\\\n  (if (< x 0)\\\\n    0.0\\\\n    (let [scaled-x (/ x 2)]\\\\n      (sin scaled-x))))\\\\n\\\\n(defn accelerated-sin-2 [x]\\\\n  (if (< x 0)\\\\n    0.0\\\\n    (let [scaled-x (/ x $pi 10.0)]\\\\n      (sin (* $pi scaled-x scaled-x)))))\\\\n\\\\n(defn accelerated-sin-3 [x]\\\\n  (if (< x 0)\\\\n    0.0\\\\n    (let [scaled-x (/ x $pi 10.0)]\\\\n      (sin (* 0.3 $pi scaled-x scaled-x scaled-x)))))\\\\n\\\\n(defn accelerated-sin-exp [x]\\\\n  (if (< x 0)\\\\n    0.0\\\\n    (let [scaled-x (/ x $pi 10)]\\\\n      (sin (- (exp scaled-x) 1)))))\\\\n\\\\n(defn make-external-temperature-fun [max driver-fun]\\\\n  (fn [t]\\\\n    (* max (driver-fun t))))\\\\n\\\\n(def external-temperature\\\\n     (make-external-temperature-fun 5.0 accelerated-sin-exp))\\\\n\\\\n(def *bees* (atom []))\\\\n\\\\n(defn make-bees [example]\\\\n  (let [start-cooling-distribution (\:start-cooling-disribution example)\\\\n\\\\tstop-cooling-distribution (\:stop-cooling-distribution example)\\\\n\\\\tnumber-of-bees (\:number-of-bees example)\\\\n\\\\tdelta-temp (\:delta-temp example)\\\\n\\\\tbees (for [i (range number-of-bees)]\\\\n\\\\t       (let [start-cooling (abs (draw start-cooling-distribution))\\\\n\\\\t\\\\t     stop-cooling (min (draw stop-cooling-distribution) (- start-cooling 0.5))\\\\n\\\\t\\\\t     start-heating (- start-cooling)\\\\n\\\\t\\\\t     stop-heating (- stop-cooling)]\\\\n\\\\t\\\\t {\:type \:\:bee,\\\\n\\\\t\\\\t  \:start-cooling start-cooling\\\\n\\\\t\\\\t  \:stop-cooling stop-cooling\\\\n\\\\t\\\\t  \:start-heating start-heating\\\\n\\\\t\\\\t  \:stop-heating stop-heating\\\\n\\\\t\\\\t  \:delta-temp delta-temp\\\\n\\\\t\\\\t  \:previous-action (atom \:\:none)}))]\\\\n    (swap\! *bees* (fn [atom] bees))\\\\n    bees))\\\\n\\\\n(defn bee-action [bee temperature]\\\\n  (let [previous-action (\:previous-action bee)\\\\n\\\\tprevious-action-value @previous-action]\\\\n    ;; Using this function bees cannot transition directly from\\\\n    ;; heating to cooling and vice versa.  Not sure whether this is correct.\\\\n    (cond (\= previous-action-value \:\:cooling)\\\\n\\\\t  (if (< temperature (\:stop-cooling bee))\\\\n\\\\t    (do\\\\n\\\\t      (swap\! previous-action (fn [action] \:\:none))\\\\n\\\\t      0.0)\\\\n\\\\t    (- (\:delta-temp bee)))\\\\n\\\\t  (\= previous-action-value \:\:heating)\\\\n\\\\t  (if (> temperature (\:stop-heating bee))\\\\n\\\\t    (do\\\\n\\\\t      (swap\! previous-action (fn [action] \:\:none))\\\\n\\\\t      0.0)\\\\n\\\\t    (\:delta-temp bee))\\\\n\\\\t  (\= previous-action-value \:\:none)\\\\n\\\\t  (cond (>\= temperature (\:start-cooling bee))\\\\n\\\\t\\\\t(do\\\\n\\\\t\\\\t  (swap\! previous-action (fn [action] \:\:cooling))\\\\n\\\\t\\\\t  (- (\:delta-temp bee)))\\\\n\\\\t\\\\t(<\= temperature (\:start-heating bee))\\\\n\\\\t\\\\t(do\\\\n\\\\t\\\\t  (swap\! previous-action (fn [action] \:\:heating))\\\\n\\\\t\\\\t  (\:delta-temp bee))\\\\n\\\\t\\\\t\:else 0.0))))\\\\n\\\\n\\\\n(defn bee-actions [bees temperature]\\\\n  (sum (map \#(bee-action % temperature) bees)))\\\\n\\\\n(defn with-offset\\\\n  ([sequence]\\\\n     (cons (first sequence) sequence))\\\\n  ([sequence n]\\\\n     (if (zero? n)\\\\n       sequence\\\\n       (recur (with-offset sequence) (- n 1)))))\\\\n\\\\n(defn time-seq [example]\\\\n  (range 0 (\:end-time example)  (\:time-step example)))\\\\n\\\\n(defn delta-t-seq [external-temperature-seq]\\\\n  (map - external-temperature-seq (with-offset external-temperature-seq)))\\\\n\\\\n(defn result-temperatures [current-t delta-t-env bees]\\\\n  (let [current-delta-t-env (first delta-t-env)\\\\n\\\\tcurrent-delta-t-bees (bee-actions bees current-t)\\\\n\\\\tnext-t (+ current-t current-delta-t-env current-delta-t-bees)]\\\\n    ;; (println [current-t current-delta-t-env current-delta-t-bees])\\\\n    (lazy-seq\\\\n     (cons current-t\\\\n\\\\t   (let [new-delta-t-env (rest delta-t-env)]\\\\n\\\\t\\\\t (if (seq new-delta-t-env)\\\\n\\\\t\\\\t   (result-temperatures next-t new-delta-t-env bees)\\\\n\\\\t\\\\t   []))))))\\\\n\\\\n(defn plot-result [& {\:keys {example\\\\n                             times\\\\n                             temperatures\\\\n                             title}}]\\\\n  (let [example (or example $default-example)\\\\n        times (or times (\:times example))\\\\n        temperatures (or temperatures (map external-temperature times))\\\\n        title (or title (\:title example))]\\\\n    (xy-plot times temperatures\\\\n     \\\\t     \:title title \\\\n     \\\\t     \:x-label \\\\\\"Time (min)\\\\\\" \:y-label \\\\\\"Temperature (\u00AC\u221EC)\\\\\\")))\\\\n\\\\n(defn run-example [example]\\\\n  (let [plot (plot-result \:example example)\\\\n        bees (make-bees example)\\\\n        times (\:times example)\\\\n        delta-t-env  (delta-t-seq (map external-temperature example))\\\\n        result-temp (result-temperatures 0.0 delta-t-env bees)]\\\\n    ;; (println delta-t-env)\\\\n    ;; (println result-temp)\\\\n    (add-lines plot time result-temp)\\\\n    (view plot)))\\\\n\\\\n(defn -main [& args]\\\\n  (run-example $default-example)\\\\n  (run-example $fixed-example))\\\\n\\") \\"/Users/tc/Prog/Clojure/Projects/bee-algorithms/src/beeAlgorithms/core.clj\\" \\"/Users/tc/Prog/Clojure/Projects/bee-algorithms/src\\")" ";; Loading file src/beeAlgorithms/core.clj" "(clojure.lang.Compiler/load (java.io.StringReader. \\"(ns beeAlgorithms.core\\\\n  (\:gen-class)\\\\n  (\:use (incanter core stats charts\\\\n\\\\t\\\\t  [distributions \:exclude [variance mean]])))\\\\n\\\\n\\\\n(def *number-of-bees* 100)\\\\n(def *end-time* 120)\\\\n(def *time-step* 1)\\\\n\\\\n(defn make-example [& {\:keys [start-cooling-distribution\\\\n\\\\t\\\\t\\\\t      stop-cooling-distribution\\\\n\\\\t\\\\t\\\\t      number-of-bees\\\\n\\\\t\\\\t\\\\t      delta-temp\\\\n\\\\t\\\\t\\\\t      end-time\\\\n\\\\t\\\\t\\\\t      time-step\\\\n\\\\t\\\\t\\\\t      title],\\\\n\\\\t\\\\t       \:or {start-cooling-distribution (normal-distribution 2.0 1.0),\\\\n\\\\t\\\\t\\\\t    stop-cooling-distribution (normal-distribution 0.0 0.1),\\\\n\\\\t\\\\t\\\\t    number-of-bees *number-of-bees*,\\\\n\\\\t\\\\t\\\\t    delta-temp (/ 1 *number-of-bees*)\\\\n\\\\t\\\\t\\\\t    end-time *end-time*\\\\n\\\\t\\\\t\\\\t    time-step *time-step*\\\\n\\\\t\\\\t\\\\t    title \\\\\\"Unnamed Example\\\\\\"}}]\\\\n  {\:start-cooling-disribution start-cooling-distribution,\\\\n   \:stop-cooling-distribution stop-cooling-distribution,\\\\n   \:number-of-bees number-of-bees\\\\n   \:delta-temp delta-temp\\\\n   \:end-time end-time\\\\n   \:time-step time-step\\\\n   \:title title})\\\\n\\\\n(def $default-example (make-example \:start-cooling-disribution (normal-distribution 1.0 0.5)\\\\n\\\\t\\\\t\\\\t\\\\t    \:stop-cooling-distribution (normal-distribution 0.5 0.1)\\\\n\\\\t\\\\t\\\\t\\\\t    \:number-of-bees *number-of-bees*\\\\n\\\\t\\\\t\\\\t\\\\t    \:delta-temp (/ 1 *number-of-bees*)\\\\n\\\\t\\\\t\\\\t\\\\t    \:title \\\\\\"Normally Distributed Default Example\\\\\\"))\\\\n\\\\n(def $fixed-example (make-example \:start-cooling-disribution [1.0]\\\\n\\\\t\\\\t\\\\t\\\\t  \:stop-cooling-distribution [0.5]\\\\n\\\\t\\\\t\\\\t\\\\t  \:number-of-bees *number-of-bees*\\\\n\\\\t\\\\t\\\\t\\\\t  \:delta-temp (/ 1 *number-of-bees*)\\\\n\\\\t\\\\t\\\\t\\\\t  \:title \\\\\\"Fixed Distribution\\\\\\"))\\\\n(def $pi java.lang.Math/PI)\\\\n\\\\n(defn sin-1 [x]\\\\n  (if (< x 0)\\\\n    0.0\\\\n    (let [scaled-x (/ x 2)]\\\\n      (sin scaled-x))))\\\\n\\\\n(defn accelerated-sin-2 [x]\\\\n  (if (< x 0)\\\\n    0.0\\\\n    (let [scaled-x (/ x $pi 10.0)]\\\\n      (sin (* $pi scaled-x scaled-x)))))\\\\n\\\\n(defn accelerated-sin-3 [x]\\\\n  (if (< x 0)\\\\n    0.0\\\\n    (let [scaled-x (/ x $pi 10.0)]\\\\n      (sin (* 0.3 $pi scaled-x scaled-x scaled-x)))))\\\\n\\\\n(defn accelerated-sin-exp [x]\\\\n  (if (< x 0)\\\\n    0.0\\\\n    (let [scaled-x (/ x $pi 10)]\\\\n      (sin (- (exp scaled-x) 1)))))\\\\n\\\\n(defn make-external-temperature-fun [max driver-fun]\\\\n  (fn [t]\\\\n    (* max (driver-fun t))))\\\\n\\\\n(def external-temperature\\\\n     (make-external-temperature-fun 5.0 accelerated-sin-exp))\\\\n\\\\n(def *bees* (atom []))\\\\n\\\\n(defn make-bees [example]\\\\n  (let [start-cooling-distribution (\:start-cooling-disribution example)\\\\n\\\\tstop-cooling-distribution (\:stop-cooling-distribution example)\\\\n\\\\tnumber-of-bees (\:number-of-bees example)\\\\n\\\\tdelta-temp (\:delta-temp example)\\\\n\\\\tbees (for [i (range number-of-bees)]\\\\n\\\\t       (let [start-cooling (abs (draw start-cooling-distribution))\\\\n\\\\t\\\\t     stop-cooling (min (draw stop-cooling-distribution) (- start-cooling 0.5))\\\\n\\\\t\\\\t     start-heating (- start-cooling)\\\\n\\\\t\\\\t     stop-heating (- stop-cooling)]\\\\n\\\\t\\\\t {\:type \:\:bee,\\\\n\\\\t\\\\t  \:start-cooling start-cooling\\\\n\\\\t\\\\t  \:stop-cooling stop-cooling\\\\n\\\\t\\\\t  \:start-heating start-heating\\\\n\\\\t\\\\t  \:stop-heating stop-heating\\\\n\\\\t\\\\t  \:delta-temp delta-temp\\\\n\\\\t\\\\t  \:previous-action (atom \:\:none)}))]\\\\n    (swap\! *bees* (fn [atom] bees))\\\\n    bees))\\\\n\\\\n(defn bee-action [bee temperature]\\\\n  (let [previous-action (\:previous-action bee)\\\\n\\\\tprevious-action-value @previous-action]\\\\n    ;; Using this function bees cannot transition directly from\\\\n    ;; heating to cooling and vice versa.  Not sure whether this is correct.\\\\n    (cond (\= previous-action-value \:\:cooling)\\\\n\\\\t  (if (< temperature (\:stop-cooling bee))\\\\n\\\\t    (do\\\\n\\\\t      (swap\! previous-action (fn [action] \:\:none))\\\\n\\\\t      0.0)\\\\n\\\\t    (- (\:delta-temp bee)))\\\\n\\\\t  (\= previous-action-value \:\:heating)\\\\n\\\\t  (if (> temperature (\:stop-heating bee))\\\\n\\\\t    (do\\\\n\\\\t      (swap\! previous-action (fn [action] \:\:none))\\\\n\\\\t      0.0)\\\\n\\\\t    (\:delta-temp bee))\\\\n\\\\t  (\= previous-action-value \:\:none)\\\\n\\\\t  (cond (>\= temperature (\:start-cooling bee))\\\\n\\\\t\\\\t(do\\\\n\\\\t\\\\t  (swap\! previous-action (fn [action] \:\:cooling))\\\\n\\\\t\\\\t  (- (\:delta-temp bee)))\\\\n\\\\t\\\\t(<\= temperature (\:start-heating bee))\\\\n\\\\t\\\\t(do\\\\n\\\\t\\\\t  (swap\! previous-action (fn [action] \:\:heating))\\\\n\\\\t\\\\t  (\:delta-temp bee))\\\\n\\\\t\\\\t\:else 0.0))))\\\\n\\\\n\\\\n(defn bee-actions [bees temperature]\\\\n  (sum (map \#(bee-action % temperature) bees)))\\\\n\\\\n(defn with-offset\\\\n  ([sequence]\\\\n     (cons (first sequence) sequence))\\\\n  ([sequence n]\\\\n     (if (zero? n)\\\\n       sequence\\\\n       (recur (with-offset sequence) (- n 1)))))\\\\n\\\\n(defn time-seq [example]\\\\n  (range 0 (\:end-time example)  (\:time-step example)))\\\\n\\\\n(defn delta-t-seq [external-temperature-seq]\\\\n  (map - external-temperature-seq (with-offset external-temperature-seq)))\\\\n\\\\n(defn result-temperatures [current-t delta-t-env bees]\\\\n  (let [current-delta-t-env (first delta-t-env)\\\\n\\\\tcurrent-delta-t-bees (bee-actions bees current-t)\\\\n\\\\tnext-t (+ current-t current-delta-t-env current-delta-t-bees)]\\\\n    ;; (println [current-t current-delta-t-env current-delta-t-bees])\\\\n    (lazy-seq\\\\n     (cons current-t\\\\n\\\\t   (let [new-delta-t-env (rest delta-t-env)]\\\\n\\\\t\\\\t (if (seq new-delta-t-env)\\\\n\\\\t\\\\t   (result-temperatures next-t new-delta-t-env bees)\\\\n\\\\t\\\\t   []))))))\\\\n\\\\n(defn plot-result [& {\:keys {example\\\\n                             times\\\\n                             temperatures\\\\n                             title}}]\\\\n  (let [example (or example $default-example)\\\\n        times (or times (\:times example))\\\\n        temperatures (or temperatures (map external-temperature times))\\\\n        title (or title (\:title example))]\\\\n    (xy-plot times temperatures\\\\n     \\\\t     \:title title \\\\n     \\\\t     \:x-label \\\\\\"Time (min)\\\\\\" \:y-label \\\\\\"Temperature (\u00AC\u221EC)\\\\\\")))\\\\n\\\\n(defn run-example [example]\\\\n  (let [plot (plot-result \:example example)\\\\n        bees (make-bees example)\\\\n        times (\:times example)\\\\n        delta-t-env  (delta-t-seq (map external-temperature example))\\\\n        result-temp (result-temperatures 0.0 delta-t-env bees)]\\\\n    ;; (println delta-t-env)\\\\n    ;; (println result-temp)\\\\n    (add-lines plot times result-temp)\\\\n    (view plot)))\\\\n\\\\n(defn -main [& args]\\\\n  (run-example $default-example)\\\\n  (run-example $fixed-example))\\\\n\\") \\"/Users/tc/Prog/Clojure/Projects/bee-algorithms/src/beeAlgorithms/core.clj\\" \\"/Users/tc/Prog/Clojure/Projects/bee-algorithms/src\\")" "(-main)" ";; Loading file src/beeAlgorithms/core.clj" "(clojure.lang.Compiler/load (java.io.StringReader. \\"(ns beeAlgorithms.core\\\\n  (\:gen-class)\\\\n  (\:use (incanter core stats charts\\\\n\\\\t\\\\t  [distributions \:exclude [variance mean]])))\\\\n\\\\n\\\\n(def *number-of-bees* 100)\\\\n(def *end-time* 120)\\\\n(def *time-step* 1)\\\\n\\\\n(defn make-example [& {\:keys [start-cooling-distribution\\\\n\\\\t\\\\t\\\\t      stop-cooling-distribution\\\\n\\\\t\\\\t\\\\t      number-of-bees\\\\n\\\\t\\\\t\\\\t      delta-temp\\\\n\\\\t\\\\t\\\\t      end-time\\\\n\\\\t\\\\t\\\\t      time-step\\\\n\\\\t\\\\t\\\\t      title],\\\\n\\\\t\\\\t       \:or {start-cooling-distribution (normal-distribution 2.0 1.0),\\\\n\\\\t\\\\t\\\\t    stop-cooling-distribution (normal-distribution 0.0 0.1),\\\\n\\\\t\\\\t\\\\t    number-of-bees *number-of-bees*,\\\\n\\\\t\\\\t\\\\t    delta-temp (/ 1 *number-of-bees*)\\\\n\\\\t\\\\t\\\\t    end-time *end-time*\\\\n\\\\t\\\\t\\\\t    time-step *time-step*\\\\n\\\\t\\\\t\\\\t    title \\\\\\"Unnamed Example\\\\\\"}}]\\\\n  {\:start-cooling-disribution start-cooling-distribution,\\\\n   \:stop-cooling-distribution stop-cooling-distribution,\\\\n   \:number-of-bees number-of-bees\\\\n   \:delta-temp delta-temp\\\\n   \:end-time end-time\\\\n   \:time-step time-step\\\\n   \:title title})\\\\n\\\\n(def $default-example (make-example \:start-cooling-disribution (normal-distribution 1.0 0.5)\\\\n\\\\t\\\\t\\\\t\\\\t    \:stop-cooling-distribution (normal-distribution 0.5 0.1)\\\\n\\\\t\\\\t\\\\t\\\\t    \:number-of-bees *number-of-bees*\\\\n\\\\t\\\\t\\\\t\\\\t    \:delta-temp (/ 1 *number-of-bees*)\\\\n\\\\t\\\\t\\\\t\\\\t    \:title \\\\\\"Normally Distributed Default Example\\\\\\"))\\\\n\\\\n(def $fixed-example (make-example \:start-cooling-disribution [1.0]\\\\n\\\\t\\\\t\\\\t\\\\t  \:stop-cooling-distribution [0.5]\\\\n\\\\t\\\\t\\\\t\\\\t  \:number-of-bees *number-of-bees*\\\\n\\\\t\\\\t\\\\t\\\\t  \:delta-temp (/ 1 *number-of-bees*)\\\\n\\\\t\\\\t\\\\t\\\\t  \:title \\\\\\"Fixed Distribution\\\\\\"))\\\\n(def $pi java.lang.Math/PI)\\\\n\\\\n(defn sin-1 [x]\\\\n  (if (< x 0)\\\\n    0.0\\\\n    (let [scaled-x (/ x 2)]\\\\n      (sin scaled-x))))\\\\n\\\\n(defn accelerated-sin-2 [x]\\\\n  (if (< x 0)\\\\n    0.0\\\\n    (let [scaled-x (/ x $pi 10.0)]\\\\n      (sin (* $pi scaled-x scaled-x)))))\\\\n\\\\n(defn accelerated-sin-3 [x]\\\\n  (if (< x 0)\\\\n    0.0\\\\n    (let [scaled-x (/ x $pi 10.0)]\\\\n      (sin (* 0.3 $pi scaled-x scaled-x scaled-x)))))\\\\n\\\\n(defn accelerated-sin-exp [x]\\\\n  (if (< x 0)\\\\n    0.0\\\\n    (let [scaled-x (/ x $pi 10)]\\\\n      (sin (- (exp scaled-x) 1)))))\\\\n\\\\n(defn make-external-temperature-fun [max driver-fun]\\\\n  (fn [t]\\\\n    (* max (driver-fun t))))\\\\n\\\\n(def external-temperature\\\\n     (make-external-temperature-fun 5.0 accelerated-sin-exp))\\\\n\\\\n(def *bees* (atom []))\\\\n\\\\n(defn make-bees [example]\\\\n  (let [start-cooling-distribution (\:start-cooling-disribution example)\\\\n\\\\tstop-cooling-distribution (\:stop-cooling-distribution example)\\\\n\\\\tnumber-of-bees (\:number-of-bees example)\\\\n\\\\tdelta-temp (\:delta-temp example)\\\\n\\\\tbees (for [i (range number-of-bees)]\\\\n\\\\t       (let [start-cooling (abs (draw start-cooling-distribution))\\\\n\\\\t\\\\t     stop-cooling (min (draw stop-cooling-distribution) (- start-cooling 0.5))\\\\n\\\\t\\\\t     start-heating (- start-cooling)\\\\n\\\\t\\\\t     stop-heating (- stop-cooling)]\\\\n\\\\t\\\\t {\:type \:\:bee,\\\\n\\\\t\\\\t  \:start-cooling start-cooling\\\\n\\\\t\\\\t  \:stop-cooling stop-cooling\\\\n\\\\t\\\\t  \:start-heating start-heating\\\\n\\\\t\\\\t  \:stop-heating stop-heating\\\\n\\\\t\\\\t  \:delta-temp delta-temp\\\\n\\\\t\\\\t  \:previous-action (atom \:\:none)}))]\\\\n    (swap\! *bees* (fn [atom] bees))\\\\n    bees))\\\\n\\\\n(defn bee-action [bee temperature]\\\\n  (let [previous-action (\:previous-action bee)\\\\n\\\\tprevious-action-value @previous-action]\\\\n    ;; Using this function bees cannot transition directly from\\\\n    ;; heating to cooling and vice versa.  Not sure whether this is correct.\\\\n    (cond (\= previous-action-value \:\:cooling)\\\\n\\\\t  (if (< temperature (\:stop-cooling bee))\\\\n\\\\t    (do\\\\n\\\\t      (swap\! previous-action (fn [action] \:\:none))\\\\n\\\\t      0.0)\\\\n\\\\t    (- (\:delta-temp bee)))\\\\n\\\\t  (\= previous-action-value \:\:heating)\\\\n\\\\t  (if (> temperature (\:stop-heating bee))\\\\n\\\\t    (do\\\\n\\\\t      (swap\! previous-action (fn [action] \:\:none))\\\\n\\\\t      0.0)\\\\n\\\\t    (\:delta-temp bee))\\\\n\\\\t  (\= previous-action-value \:\:none)\\\\n\\\\t  (cond (>\= temperature (\:start-cooling bee))\\\\n\\\\t\\\\t(do\\\\n\\\\t\\\\t  (swap\! previous-action (fn [action] \:\:cooling))\\\\n\\\\t\\\\t  (- (\:delta-temp bee)))\\\\n\\\\t\\\\t(<\= temperature (\:start-heating bee))\\\\n\\\\t\\\\t(do\\\\n\\\\t\\\\t  (swap\! previous-action (fn [action] \:\:heating))\\\\n\\\\t\\\\t  (\:delta-temp bee))\\\\n\\\\t\\\\t\:else 0.0))))\\\\n\\\\n\\\\n(defn bee-actions [bees temperature]\\\\n  (sum (map \#(bee-action % temperature) bees)))\\\\n\\\\n(defn with-offset\\\\n  ([sequence]\\\\n     (cons (first sequence) sequence))\\\\n  ([sequence n]\\\\n     (if (zero? n)\\\\n       sequence\\\\n       (recur (with-offset sequence) (- n 1)))))\\\\n\\\\n(defn time-seq [example]\\\\n  (range 0 (\:end-time example)  (\:time-step example)))\\\\n\\\\n(defn delta-t-seq [external-temperature-seq]\\\\n  (map - external-temperature-seq (with-offset external-temperature-seq)))\\\\n\\\\n(defn result-temperatures [current-t delta-t-env bees]\\\\n  (let [current-delta-t-env (first delta-t-env)\\\\n\\\\tcurrent-delta-t-bees (bee-actions bees current-t)\\\\n\\\\tnext-t (+ current-t current-delta-t-env current-delta-t-bees)]\\\\n    ;; (println [current-t current-delta-t-env current-delta-t-bees])\\\\n    (lazy-seq\\\\n     (cons current-t\\\\n\\\\t   (let [new-delta-t-env (rest delta-t-env)]\\\\n\\\\t\\\\t (if (seq new-delta-t-env)\\\\n\\\\t\\\\t   (result-temperatures next-t new-delta-t-env bees)\\\\n\\\\t\\\\t   []))))))\\\\n\\\\n(defn plot-result [& {\:keys {example\\\\n                             times\\\\n                             temperatures\\\\n                             title}}]\\\\n  (let [example (or example $default-example)\\\\n        times (or times (\:times example))\\\\n        temperatures (or temperatures (map external-temperature times))\\\\n        title (or title (\:title example))]\\\\n    (xy-plot times temperatures\\\\n     \\\\t     \:title title \\\\n     \\\\t     \:x-label \\\\\\"Time (min)\\\\\\" \:y-label \\\\\\"Temperature (\u00AC\u221EC)\\\\\\")))\\\\n\\\\n(defn run-example [example]\\\\n  (let [plot (plot-result \:example example)\\\\n        bees (make-bees example)\\\\n        times (\:times example)\\\\n        delta-t-env  (delta-t-seq (map external-temperature example))\\\\n        result-temp (result-temperatures 0.0 delta-t-env bees)]\\\\n    ;; (println delta-t-env)\\\\n    ;; (println result-temp)\\\\n    (add-lines plot times result-temp)\\\\n    (view plot)))\\\\n\\\\n(defn -main [& args]\\\\n  (run-example $default-example)\\\\n  (run-example $fixed-example))\\\\n\\\\n(-main)\\\\n\\") \\"/Users/tc/Prog/Clojure/Projects/bee-algorithms/src/beeAlgorithms/core.clj\\" \\"/Users/tc/Prog/Clojure/Projects/bee-algorithms/src\\")"]
eclipse.preferences.version=1
